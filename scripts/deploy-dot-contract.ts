#!/usr/bin/env tsx

import { ApiPromise, WsProvider } from "@polkadot/api";
import { CodePromise, ContractPromise } from "@polkadot/api-contract";
import { Keyring } from "@polkadot/keyring";
import { KeyringPair } from "@polkadot/keyring/types";
import { ISubmittableResult } from "@polkadot/types/types";
import * as fs from "fs";
import * as path from "path";

// Load contract metadata and wasm
const contractPath = path.join(__dirname, "../polkadotrelayer/target/ink/polkadotrelayer.contract");
const contractData = JSON.parse(fs.readFileSync(contractPath, "utf8"));

async function deployContract() {
  console.log("üöÄ Starting Polkadot contract deployment...");

  // Connect to Polkadot node
  const wsProvider = new WsProvider(process.env.POLKADOT_WS_URL || "wss://ws.test.azero.dev");
  const api = await ApiPromise.create({ provider: wsProvider });

  console.log("‚úÖ Connected to Polkadot node");

  // Setup account
  const keyring = new Keyring({ type: "sr25519" });
  const account: KeyringPair = keyring.addFromUri(process.env.POLKADOT_SEED || "//Alice");

  console.log(`üìù Deploying from account: ${account.address}`);

  // Check account balance
  const accountInfo = await api.query.system.account(account.address);
  const balance = (accountInfo as any).data;
  console.log(`üí∞ Account balance: ${balance.free.toHuman()}`);

  try {
    // Create code promise from contract data
    const code = new CodePromise(api, contractData, contractData.source.wasm);

    console.log("üì¶ Contract code loaded, starting deployment...");

    // First, let's do a dry run to estimate gas
    console.log("üß™ Performing dry run to estimate gas...");
    
    try {
      const dryRun = await api.call.contractsApi.instantiate(
        account.address,
        0, // value
        null, // gasLimit (null for estimation)
        null, // storageDepositLimit
        contractData.source.hash,
        "0x9bae9d5e", // constructor selector for "new"
        "0x" // constructor args (empty for new())
      );
      
      console.log("Dry run result:", dryRun.toHuman());
    } catch (error) {
      console.log("Dry run failed, proceeding with manual gas limits:", error);
    }

    // Deploy the contract with very conservative gas limits for Aleph Zero
    const tx = code.tx.new({
      gasLimit: api.registry.createType('WeightV2', {
        refTime: api.registry.createType('Compact<u64>', 1_000_000), // Very low gas for Aleph Zero
        proofSize: api.registry.createType('Compact<u64>', 1_000),   // Very low proof size
      }) as any,
      storageDepositLimit: null,
      value: 0, // No value needed for constructor
    });

    console.log("‚è≥ Submitting deployment transaction...");

    const result = await new Promise<{
      contract?: ContractPromise;
      address?: string;
      error?: string;
    }>((resolve) => {
      tx.signAndSend(account, (result: ISubmittableResult) => {
        console.log(`   Transaction status: ${result.status.type}`);

        if (result.status.isInBlock) {
          console.log(`   üì¶ Transaction included in block: ${result.status.asInBlock.toHex()}`);
        }

        if (result.status.isFinalized) {
          console.log(`   ‚úÖ Transaction finalized in block: ${result.status.asFinalized.toHex()}`);

          // Find the contract instantiated event
          const contractEvent = result.events.find(({ event }) =>
            api.events.contracts.Instantiated.is(event)
          );

          if (contractEvent) {
            const contractAddress = contractEvent.event.data[1].toString();
            console.log(`   üéâ Contract deployed at address: ${contractAddress}`);

            const contract = new ContractPromise(api, contractData, contractAddress);
            resolve({ contract, address: contractAddress });
          } else {
            console.error("   ‚ùå Contract instantiation event not found");
            resolve({ error: "Contract instantiation event not found" });
          }
        }

        if (result.isError) {
          console.error("   ‚ùå Transaction failed");
          resolve({ error: "Transaction failed" });
        }
      }).catch((error) => {
        console.error("   ‚ùå Transaction submission failed:", error);
        resolve({ error: error.message });
      });
    });

    if (result.error) {
      console.error("‚ùå Deployment failed:", result.error);
      process.exit(1);
    }

    if (result.address) {
      console.log("\nüéâ Contract deployment successful!");
      console.log(`üìç Contract Address: ${result.address}`);
      console.log("\nüìù Update your .env file with the new contract address:");
      console.log(`POLKADOT_CONTRACT_ADDRESS=${result.address}`);
      
      // Test the deployed contract
      console.log("\nüß™ Testing deployed contract...");
      const contract = result.contract!;
      
      // Test a simple query to verify the contract is working
      try {
        const { result: queryResult } = await contract.query.contractExists(
          account.address,
          {
            gasLimit: api.registry.createType('WeightV2', {
              refTime: api.registry.createType('Compact<u64>', 10_000_000),
              proofSize: api.registry.createType('Compact<u64>', 10_000),
            }) as any,
            storageDepositLimit: null,
          },
          "test_contract_id"
        );

        if (queryResult.isOk) {
          console.log("‚úÖ Contract is responding to queries correctly");
        } else {
          console.log("‚ö†Ô∏è  Contract query returned error (this might be expected for non-existent contract)");
        }
      } catch (error) {
        console.log("‚ö†Ô∏è  Contract query test failed:", error);
      }
    }

  } catch (error) {
    console.error("‚ùå Deployment error:", error);
    process.exit(1);
  } finally {
    await api.disconnect();
    console.log("üëã Disconnected from Polkadot node");
  }
}

// Run deployment
deployContract().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});